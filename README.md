# MiniKotlin to Java CPS Compiler

This is an internship assignment for implementing a CPS-style (Continuation-Passing Style) compiler from MiniKotlin (a subset of Kotlin) to Java.

## Overview

The goal is to implement a compiler that translates MiniKotlin source code into Java, where all functions are expressed using continuation-passing style.

## Architecture

The compiler parses the MiniKotlin program into an Abstract Syntax Tree (AST), performs semantic analysis, and generates Java Continuation-Passing-Style code. 

### Development History

The architecture changed drastically during development:
* The initial naive implementation worked directly with the node contexts generated by ANTLR. This was later discarded and rewritten to construct and operate on a dedicated AST, providing a cleaner separation of concerns and more robust semantic analysis phase.
* The initial ANTLR-based implementation was stress-tested using a custom fuzzer that generated MiniKotlin programs in textual form. When the architecture shifted to the AST, this text-based fuzzer was discarded. I am currently considering implementing a new fuzzer that operates purely on AST node generation.
* I have created custom tests to strictly validate the compiler's correct functionality against edge cases that appeared during the compiler testing and review.

## Implementation Details

### Mutable State in Closures

MiniKotlin allows local variables to be mutated. However, the generated code relies heavily on lambdas (Continuation<T>), which require captured variables to be effectively final. To solve this, the compiler maps MiniKotlin variable declarations to single-element arrays in Java. 

* **MiniKotlin:** `var x: Int = 5`
* **Java Generation:** `Integer[] x_0 = new Integer[] { 5 };`

### Short-Circuit Evaluation

Logical operators (&& and ||) correctly short-circuit. Instead of evaluating both sides and passing them to a boolean operation, the compiler generates a continuation branch after evaluating the left side. Additionally, both these operators and if statements are optimised to avoid exponential code growth on sequential calls.

### Variable Scopes And Shadowing

The semantic analyzer uses a stack of maps to track variable scopes. It supports parameter shadowing mirroring Kotlin's scoping semantics.

## Known Limitations

**Tail Call Optimization (TCO)**
The JVM does not natively support TCO. The compiler implements while loops using a recursive continuation pattern. I did not implement trampolining, so extreme loop iterations will eventually throw a StackOverflowError.
